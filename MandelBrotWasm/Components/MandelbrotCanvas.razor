@using MandelBrotWasm.Logic

@inject IJSRuntime JSRuntime

@if (_busy)
{
    <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.Center" AlignItems="AlignItems.Center" Wrap="FlexWrap.Wrap" Style="position: absolute; width: 100%; height: 100%; background: #00000010">
        <RadzenStack Orientation="Orientation.Vertical" JustifyContent="JustifyContent.Center" AlignItems="AlignItems.Center">
            <RadzenProgressBarCircular ProgressBarStyle="ProgressBarStyle.Primary" Value="@_progress" ShowValue="false" Mode="ProgressBarMode.Determinate" />
            <RadzenText Text="Rendering"/>
        </RadzenStack>
    </RadzenStack>
}
<div style="width: 100%; height: 100vh;">
    <BECanvas @ref="_beCanvas" Width="800" Height="800" />
</div>

<ControlPanel RenderRequested="OnRenderRequested" PreviewRequested="OnPreviewRequested" Busy="@_busy"/>

@code {
    private BECanvasComponent _beCanvas;
    //private CpuMandelbrotRenderContext _context;
    private GpuMandelbrotRenderContext _context;
    private bool _busy = false;
    private bool _shouldRender = true;
    private bool _shouldPreview = false;
    private float _progress = 0f;


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_busy)
        {
            if (firstRender)
            {
                //_context = new CpuMandelbrotRenderContext(_beCanvas, JSRuntime);
                _context = new GpuMandelbrotRenderContext(_beCanvas, JSRuntime);
                _context.OnPresent += OnPresent;
                _context.OnProgress += (sender,progress) => { _progress = float.Round(progress * 100f,2); StateHasChanged(); };
            }

            if (_shouldRender)
            {
                _busy = true;
                _shouldRender = false;

                await HideImg();

                _context.Render();

                StateHasChanged();
            }
            else if (_shouldPreview)
            {
                _busy = true;
                _shouldPreview = false;
                await HideImg();
                _context.Preview();
                StateHasChanged();
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private void OnRenderRequested(RenderRequestedEventArgs e){
        _context.MaxIterations = e.MaxIterations;
        _context.Scale = 1f/e.Zoom;
        _context.OffsetX = e.OffsetX;
        _context.OffsetY = e.OffsetY;

        _shouldRender = true;

        StateHasChanged();
    }

    private void OnPreviewRequested(RenderRequestedEventArgs e)
    {
        _context.MaxIterations = e.MaxIterations;
        _context.Scale = 1f / e.Zoom;
        _context.OffsetX = e.OffsetX;
        _context.OffsetY = e.OffsetY;

        _shouldPreview = true;

        StateHasChanged();
    }

    private async Task HideImg() => await JSRuntime.InvokeVoidAsync("hideImg");

    private void OnPresent(object? sender, EventArgs e)
    {
        _busy = false;
        StateHasChanged();
    }
}
